// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "script/Deploy.s.sol";
import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

import "src/pools/constant-product/ConstantProductPool.sol";
import "src/pools/ConstantProductLibrary.sol";

contract SwapFacetHarness is SwapFacet {
    using PoolBalanceLib for bytes32;

    constructor(IVC vc_, Token ballot_) SwapFacet(vc_, ballot_) {}

    function getPoolBalance(IPool pool, Token tok) external view returns (uint256) {
        return _poolBalances()[pool][tok].secondU();
    }

    function getGaugeBalance(IPool pool, Token tok) external view returns (uint256) {
        return _poolBalances()[pool][tok].firstU();
    }
}

contract MockVeVC is ERC20 {
    constructor() ERC20("veLOL", "veLOL") {}

    function mint(uint256 n) external {
        _mint(msg.sender, n);
    }
}

contract DumbPool is PoolWithLPToken {
    constructor(IVault vault) Pool(vault) {
        _initialize("lol", "asdf");
    }

    function velocore__execute(address user, Token[] calldata tokens, int128[] memory amounts, bytes calldata data)
        external
        override
        returns (int128[] memory, int128[] memory)
    {
        return (new int128[](tokens.length), amounts);
    }

    function velocore__gauge(
        address user,
        uint128 newEmissions,
        Token[] calldata tokens,
        int128[] memory amounts,
        bytes calldata data
    ) external returns (int128[] memory deltaGauge, int128[] memory deltaPool) {
        return (amounts, new int128[](tokens.length));
    }

    function exposed_getPoolBalance(Token tok) external returns (uint256) {
        return _getPoolBalance(tok);
    }
}

contract StubbornPool is IPool {
    function velocore__execute(address user, Token[] calldata tokens, int128[] memory amounts, bytes calldata data)
        external
        override
        returns (int128[] memory, int128[] memory)
    {
        for (uint256 i = 0; i < tokens.length; i++) {
            amounts[i] = 10000;
        }
        return (new int128[](tokens.length), amounts);
    }
}

contract PoolTest is Test {
    IVault public vault;
    VC public vc;
    VeVC public veVC;
    MockVeVC public usdc;
    MockVeVC public btc;
    ConstantProductPool cpmm;

    function setUp() public {
        (vault, vc, veVC) = (new DeployScript()).deploy();
        usdc = new MockVeVC();
        btc = new MockVeVC();
        Token[] memory tokens = new Token[](2);
        tokens[0] = toToken(usdc);
        tokens[1] = toToken(btc);
        uint256[] memory weights = new uint256[](2);
        weights[0] = 1;
        weights[1] = 1;
        cpmm = new ConstantProductPool(
            IConstantProductLibrary(address(new ConstantProductLibrary())), IVault(address(vault)), "pool1", "Pool", tokens, weights, 0);
    }

    function _deposit(uint96 balA, uint96 balB) public returns (int128[] memory r) {
        Token[] memory tokens = new Token[](3);
        int128[] memory initial = new int128[](3);
        bytes32[] memory tokenInfo = new bytes32[](3);
        VelocoreOperation[] memory ops = new VelocoreOperation[](1);
        tokens[1] = toToken(cpmm);
        tokens[2] = toToken(btc);
        tokens[0] = toToken(usdc);

        tokenInfo[1] = bytes32(bytes2(0x0101)) | PoolBalanceLib.pack(0, int256(type(int128).max));
        tokenInfo[2] = bytes32(bytes2(0x0200)) | PoolBalanceLib.pack(uint256(0), balA);
        tokenInfo[0] = bytes32(bytes2(0x0000)) | PoolBalanceLib.pack(uint256(0), balB);

        btc.mint(balA);
        btc.approve(address(vault), type(uint256).max);
        usdc.mint(balB);
        usdc.approve(address(vault), type(uint256).max);
        ops[0] = VelocoreOperation({
            poolId: bytes32(bytes1(0x00)) | bytes32(uint256(uint160(address(cpmm)))),
            tokenInformations: tokenInfo,
            data: hex""
        });
        vault.execute(tokens, initial, ops);
    }

    function _withdraw(uint256 lp) public returns (int128[] memory r) {
        Token[] memory tokens = new Token[](3);
        int128[] memory initial = new int128[](3);
        bytes32[] memory tokenInfo = new bytes32[](3);
        VelocoreOperation[] memory ops = new VelocoreOperation[](1);
        tokens[1] = toToken(cpmm);
        tokens[2] = toToken(btc);
        tokens[0] = toToken(usdc);

        tokenInfo[1] = bytes32(bytes2(0x0100)) | PoolBalanceLib.pack(uint256(0), lp);
        tokenInfo[2] = bytes32(bytes2(0x0201)) | PoolBalanceLib.pack(0, int256(type(int128).max));
        tokenInfo[0] = bytes32(bytes2(0x0000)) | PoolBalanceLib.pack(uint256(0), 0);

        ops[0] = VelocoreOperation({
            poolId: bytes32(bytes1(0x00)) | bytes32(uint256(uint160(address(cpmm)))),
            tokenInformations: tokenInfo,
            data: hex""
        });
        vault.execute(tokens, initial, ops);
    }

    function deposit2(uint96 balA, uint96 balB, uint96 balC, uint96 balD) public {
        vm.assume(balA > 10000000 && balB > 10000000);
        btc.approve(address(vault), type(uint256).max);
        usdc.approve(address(vault), type(uint256).max);
        btc.mint(1000000000000000000);
        usdc.mint(100000000000000000);
        _deposit(balA, balB);
        uint256 a = cpmm.balanceOf(address(this));
        _deposit(1000, 1000);
        uint256 b = cpmm.balanceOf(address(this));
        if (a >= b) return;
        uint256 c = btc.balanceOf(address(this));
        uint256 d = usdc.balanceOf(address(this));
        _withdraw((b - a));
        require(
            int256(btc.balanceOf(address(this))) - int256(c) <= 1000
                || int256(usdc.balanceOf(address(this))) - int256(d) <= 1000
        );
    }

    function testFuzz_deposit3(uint96 balA, uint96 balB) public {
        btc.approve(address(vault), type(uint256).max);
        usdc.approve(address(vault), type(uint256).max);
        btc.mint(1000000000000000000);
        usdc.mint(100000000000000000);
        _deposit(balA, balB);
        uint256 a = cpmm.balanceOf(address(this));
        _deposit(1000, 0);
        uint256 b = cpmm.balanceOf(address(this));
        vm.assume(a < b);
        uint256 c = btc.balanceOf(address(this));
        uint256 d = usdc.balanceOf(address(this));
        _withdraw((b - a));
        require(int256(btc.balanceOf(address(this))) - int256(c) <= 1000);
    }
}

// use each of opType
// test when emission > 0, emission == 0
// test when vote > 0, vote == 0, vote < 0
